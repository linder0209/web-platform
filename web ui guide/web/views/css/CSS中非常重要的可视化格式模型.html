<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>CSS中非常重要的可视化格式模型</title>
        <link rel="stylesheet" href="../../platform/css/base.css" type="text/css"/>
        <link rel="stylesheet" href="../../platform/css/platform.css" type="text/css"/>
        <link rel="stylesheet" href="../../platform/css/theme/skyblue.css" type="text/css"/>
        <link rel="stylesheet" href="../../platform/css/web.css" type="text/css"/>

        <link type="text/css" rel="stylesheet" href="../../platform/javascript/syntaxhighlighter/styles/shCoreDefault.css"/>

        <script type="text/javascript" src="../../platform/javascript/jquery/jquery.js"></script>

        <script type="text/javascript" src="../../platform/javascript/syntaxhighlighter/scripts/shCore.js"></script>
        <script type="text/javascript" src="../../platform/javascript/syntaxhighlighter/scripts/shBrushXml.js"></script>
        <script type="text/javascript" src="../../platform/javascript/syntaxhighlighter/scripts/shBrushJScript.js"></script>
        <style>
            body{
                padding:10px;
            }
        </style>
        <script type="text/javascript">
            $(function() {
                $('.h-web-catalogue li a').click(function(e) {
                    e.preventDefault();
                    var paragraphNum,
                            paragraph,
                            offset;
                    var el = this;
                    $(this).closest('ol').find('li a').each(function(index, element) {
                        if (this === el) {
                            paragraphNum = index;
                            return false;
                        }
                    });
                    paragraph = $('.h-web-paragraph h3[paragraph]').eq(paragraphNum);
                    offset = paragraph.offset();
                    if (offset) {
                        $(window).scrollTop(offset.top);
                    }
                });
                //初始化内容折叠事件
                $('.h-web-paragraph').on('click', 'h3[paragraph]', function(e) {
                    $(this).next().toggle();
                });

                //SyntaxHighlighter
                $('pre').replaceWith(function() {
                    var html = '<pre type="syntaxhighlighter" class="brush: js; html-script: true; quick-code: false; toolbar : false" >';
                    html += $(this).html();
                    html += '</pre>';
                    return html;
                });
                SyntaxHighlighter.highlight();
            });
        </script>
    </head>
    <body>
        <h3 class="h-web-paragraph-title">目录</h3>
        <ol class="h-web-catalogue">
            <li><a paragraph href="#">可视化格式模型介绍</a></li>
            <li><a paragraph href="#">包含块(containing block)</a></li>
            <li><a paragraph href="#">控制框(Controlling box)</a></li>
            <li><a paragraph href="#">CSS 字体</a></li>
            <li><a paragraph href="#">CSS 列表</a></li>
            <li><a paragraph href="#">CSS 表格</a></li>
            <li><a paragraph href="#">CSS 轮廓</a></li>
            <li><a paragraph href="#">关于CSS 框模型即盒子模型的一些注意事项</a></li>
            <li><a paragraph href="#">CSS 定位和CSS 浮动</a></li>
            <li><a paragraph href="#">CSS 选择器</a></li>
            <li><a paragraph href="#">CSS中其他一些样式</a></li>
            <li><a paragraph href="#">CSS 参考手册</a></li>

        </ol>
        <div class="h-web-paragraph">
            <h3 paragraph>可视化格式模型介绍</h3>
            <div>
                <p>三维的可视化格式模型（<a href="http://www.w3.org/TR/CSS2/visuren.html">Visual formatting model</a>）
                    是非常抽象的概念。它是 CSS 布局的核心，通过它，框( box )可以获得应有的尺寸，放到需要的位置。 </p>
                <p>可视化格式模型的官方说法是，它规定了用户端在媒介中如何处理文档树( document tree )。以下是对其中关键词的解释：</p>
                <ul>
                    <li>用户端：对我们来说一般指浏览器。</li>
                    <li>媒介：展现页面的介质。例如，纸媒介，听觉浏览器和显示器等3。</li>
                    <li>文档树( document tree )：源文档中元素树的编码。树中，每一个元素恰好由一个父元素。根元素是例外，它没有父元素。就是 document 和页面上的元素所构成的类似树形的结构。</li>
                </ul>
                <p>可视化格式模型涵盖的东西比较多，只有彻底把这些概念和用法搞明白了，才能正确理解和掌握页面中文档树的结构和布局。
                    涉及的内容有盒子模型，块级元素和块框，行内元素和行框，浮动，定位分层等。</p>
                <p>在可视化格式模型中，每一个元素都会根据盒子模型产生0个或多个box，而这些box的布局受以下因素的影响：</p>
                <ol>
                    <li>box尺寸和类型
                        <br>
                        类型是指 display 选项值所决定的元素类型，如：DIV 是块级元素，SPAN 是行内元素等，这个特性会使元素产生相应的<a href="http://www.w3.org/TR/CSS2/visuren.html#box-gen" target="new">控制框，Controlling box</a></li>
                    <li>定位布局 <br>
                        元素在布局时，会根据4种定位来布局文档流。分别是，常规流、相对定位、绝对定位和固定定位（static,relative,absolute,fixed）。</li>
                    <li>在文档树中，元素之间的关系<br>
                        比如，一个块元素包含两个互为兄弟节点的浮动元素，后面那个浮动元素的布局，会受前面元素以及它包含块的影响。 </li>
                    <li>外部信息（视口大小，内在图像的尺寸等）<br>
                        比如，可视窗口的大小，我们有时候会做页面自适应窗口大小的功能，就是因为，窗口大小对布局有影响。再如，图片的固有尺寸，会影响行内替换元素的尺寸，进而影响这个布局。</li>
                </ol>
                <p>                   这部分定义的特性，适用于 <a href="http://www.w3.org/TR/CSS2/media.html#continuous-media-group" target="_blank">continuous media</a> 和 <a href="http://www.w3.org/TR/CSS2/media.html#paged-media-group" target="_blank"> paged media</a>。当作用于 <a href="http://www.w3.org/TR/CSS2/media.html#paged-media-group" target="_blank">paged media</a>时，margin的意义有所改变。</p>
                <p>可视化格式模型不会指定各方面（比如，它不指定一个字母间距算法的）。用户端的一致性（ <a href="http://www.w3.org/TR/CSS2/conform.html#conformance" target="_blank">Conforming user agents</a> ）在处理本规范未包含的格式化情形时，表现也会有所不同。</p>
                <p class="h-web-font-red">上边两句话不是很理解，有待后续研究。</p>
                <p>可视化格式模型有两个重要概念，分别是 The viewport 和 Containing blocks</p>
                <p>The viewport：应该为 <a href="http://www.w3.org/TR/CSS2/media.html#continuous-media-group" target="_blank">continuous media</a> 提供一个可视窗口viewport（一个窗口或是屏幕的一部分），当 viewport大小改变了，文档布局大小也应该做出调整来适应viewport，当<br>
                    viewport太小不能呈现文档时应提供滚动条，每个画布至多提供一个可视窗口，但是浏览器可以同时渲染多个画布，这就需要为每个画布提供一个可视窗口。</p>
                <p> Containing blocks：在CSS2.1中，很多box的定位和尺寸的计算，都取决于一个矩形的边界，这个矩形，就被称作是包含块(containing block)。一般来说，(元素)生成的box会扮演它子孙元素包含块的角色；我们称之为：一个(元素的)box为它的子孙节点建造了包含块。包含块是一个相对的概念。每个box关于它的包含块都有一个位置，但是它不会被包含块限制；它可以<a href="http://www.w3.org/TR/CSS2/visufx.html#overflow">溢出</a>(包含块)。</p>
                <p>下面的章节详细的讲解了这部分的内容，主要包括：<a href="http://www.w3.org/TR/CSS2/visudet.html#containing-block-details" target="_blank">包含块(containing block)</a>、<a href="http://www.w3.org/TR/CSS2/visuren.html#box-gen" target="_blank">控制块（Controlling box）</a></p>
            </div>
            <h3 paragraph>包含块(containing block)</h3>
            <div>
                <p>
                    一个元素box有他的位置和大小，这个区域是以一个矩形来展现的，我们称之为矩形框，这个矩形框就是我们说的包含块。同样，元素形成的矩形框会为他的子孙创建包含块，包含块是一个相对的概念。</p>
                <p>我们以下面的代码说明</p>
                <pre>
<div>
    <table>
        <tr>
            <td>hello</td>
        </tr>
    </table>
</div>
                </pre>
                <p> div 和 table 都是包含块。div 是 table 的包含块，同时 table 又是 td 的包含块，不是绝对的。</p>
                <p>&ldquo;一个框的包含块&rdquo;，指的是&ldquo;该框所存在的那个包含块&rdquo;，并不是它建造的包含块。比如，上述代码中，table 的包含块，说的是 div 建造的包含块，而不是 table 自身建造的包含块。table 建造的包含块，可以称作 td 的包含块。</p>
                <p>这里需要说明一下，元素的包含块不一定是他的父元素，这一点存在于浮层和绝对定位中等其他布局。看下面的例子： </p>
                <div style="position: relative;height: 60px; border: 1px solid #00BEEE;color: #009ec3;">
                    这是祖先节点小a
                    <div style="border:1px solid #CCCCCC;color: #ED2754;">
                        这是他的父节点小b
                        <div style="position: absolute;left:0;top:0;padding-left: 200px;color: deeppink;">
                            该节点的父节点是下b，但由于为该元素设置了绝对定位，他的包含块不再是他的父节点下b，而是祖先节点小a
                        </div>
                    </div>
                </div>
                <p>所以一个元素的包含块跟元素自身以及他祖先元素样式有关（主要指display，定位以及浮层），那我们怎么判断确定元素的包含块呢，请看下面的流程图：</p>
                <img src="images/containing block.png"/>
                <h2>根元素的包含块</h2>
                <p>
                    根元素，就是处于文档树最顶端的元素，它没有父节点。
                    根元素存在的包含块，被叫做初始包含块 (initial containing block)。具体，跟用户端有关。
                    在(X)HTML中，根元素是html元素（尽管有的浏览器会不正确地使用body元素）。 另外初始包含块的 direction 属性与根元素相同。</p>
                <h2>static和relative定位的元素的包含块</h2>
                <p>
                    如果元素的定位（position）为 “relative”（相对定位）或者 “static”（静态定位），它的包含块由它最近的块级、单元格 （table cell）或者行内块（inline-block）祖先元素的内容框创建。
                </p>
                <p>看下面的例子：</p>
                <pre>
<table name="table1">
    <tbody>
        <tr>
            <td name="td1">
                <div name="div1" style="padding:20px;border:1px solid #00BEEE;">
                    <span>
                        <strong name="relative1" style="position:relative;">相对定位</strong>
                        内容值
                    </span>
                </div>
            </td>
        </tr>
    </tbody>
</table>
                </pre>
                <p>包含块关系表</p>
                <table cellspacing="0" cellpadding="0">
                    <tr>
                        <th>元素</th>
                        <th>包含块</th>
                    </tr>
                    <tr>
                        <td>table1</td>
                        <td>body（根元素）</td>
                    </tr>
                    <tr>
                        <td>td1</td>
                        <td>table1（块级）</td>
                    </tr>
                    <tr>
                        <td>div1</td>
                        <td>td1（table-cell）</td>
                    </tr>
                    <tr>
                        <td>relative1</td>
                        <td>div1（祖先元素是块级）</td>
                    </tr>
                    <tr>
                        <td>span</td>
                        <td>div1（块级）</td>
                    </tr>
                </table>
                <h2>position:fixed 定位元素的包含块</h2>
                <p>如果元素是固定定位 ("position:fixed") 元素，那么它的包含块是当前可视窗口（即根元素），看下面代码</p>
                <pre>
<div style="position: absolute;">
    <div style="position: fixed;">
        设置为fixed，则它的包含块是body
    </div>
</div></pre>
                <h2>position: absolute定位元素的包含块</h2>
                <p>总的来说，绝对定位（"position: absolute"）元素的包含块由离它最近的 'position' 属性为 'absolute'、'relative' 或者 'fixed' 的祖先元素创建。</p>
                <p>如果其祖先元素是行内元素，则包含块取决于其祖先元素的 'direction' 特性</p>
                <p><strong>1). 如果 'direction' 是 'ltr'，包含块的顶、左边是祖先元素生成的第一个框的顶、左内边距边界(padding edges) ，右、下边是祖先元素生成的最后一个框的右、下内边距边界(padding edges)</strong>，看以下例子：</p>
                <pre>
<div style="border: 1px solid #CCCCCC;padding: 40px;width:200px;">
    祖先元素
    <span style="border:1px solid #00BEEE;color: #ED2754;position:relative;padding: 20px;">
        相对定位的行内元素，其子元素ABC的包含块顶、左边应该是SPAN 形成的第一个框（即第一行）的顶、左内边距边，
        ABC包含块的右、下边是 SPAN 生成的最后一个框（最后一行）的右、下内边距边界
        <i style="position: absolute;top:0;left:0;color: deeppink;font-weight: bold; ">A</i>
        <i style="position: absolute;top: 20px; left:0;color: #009ec3;font-weight: bold; ">B</i>
        <i style="position: absolute;bottom:0; right:0;color: #B266B2;font-weight: bold; ">C</i>
    </span>
</div>
                </pre>
                <div style="border: 1px solid #CCCCCC;padding: 40px;width:200px;">
                    祖先元素
                    <span style="border:1px solid #00BEEE;color: #ED2754;position:relative;padding: 20px;">
                        相对定位的行内元素，其子元素ABC的包含块顶、左边应该是SPAN 形成的第一个框（即第一行）的顶、左内边距边，
                        ABC包含块的右、下边是 SPAN 生成的最后一个框（最后一行）的右、下内边距边界
                        <i style="position: absolute;top:0;left:0;color: deeppink;font-weight: bold; ">A</i>
                        <i style="position: absolute;top: 20px; left:0;color: #009ec3;font-weight: bold; ">B</i>
                        <i style="position: absolute;bottom:0; right:0;color: #B266B2;font-weight: bold; ">C</i>
                    </span>
                </div>
                <p>
                    从以上例子可以看出，对于'direction' 是 'ltr'，即文字从左向右排列，行内元素形成的包含块是指行内元素第一个框的顶、左内边距边（padding的外层，border的内边）
                    和最后一个框的右、下内边距边界（padding的外侧，border的内边），除了firefox，其他浏览器都按这一规则处理的。而firefox中表现的是，
                    行内元素形成的包含块是指行内元素第一个框的顶、左内边距边（padding的外层，border的内边）和第一个框的右、下内边距边界（padding的外侧，border的内边），<span class="h-web-font-red">只在第一个框里</span>。 </p>
                <p>以下是非firefox和firefox下的截图</p>
                <div style="display: table-row;">
                    <div style="display: table-cell;">
                        <img src="images/chrome下行内元素形成的包含块.png" alt="chrome下行内元素形成的包含块" title="chrome下行内元素形成的包含块" />
                        <div style="text-align: center;">非firefox(以chrome为例)下行内元素形成的包含块</div>
                    </div>
                    <div style="display: table-cell;">
                        <img src="images/firefox下行内元素形成的包含块.png" alt="firefox下行内元素形成的包含块" title="firefox下行内元素形成的包含块" />
                        <div style="text-align: center;">firefox下行内元素形成的包含块</div>
                    </div>
                </div>
                <p>当然，包含块的宽度可能是<span class="h-web-font-red">负的</span>。这种情况下各浏览器表现的又不太一样，主要是ie6和ie7，看以下例子：</p>

                <div style="border: 1px solid #CCCCCC;padding: 40px;width:200px;">
                    祖先元素祖先元素祖先元素
                    <span style="border:1px solid #00BEEE;color: #ED2754;position:relative;padding: 20px;">
                        相对定位的行内元素，其子元素ABC的包含块顶、左边应该是SPAN 形成的第一个框（即第一行）的顶、左内边距边，
                        ABC包含块的右、下边是 SPAN 生成的最后一个框（最后一行）的右、下内边距边界
                        <i style="position: absolute;top:0;left:0;color: deeppink;font-weight: bold; ">A</i>
                        <i style="position: absolute;top: 20px; left:0;color: #009ec3;font-weight: bold; ">B</i>
                        <i style="position: absolute;bottom:0; right:0;color: #B266B2;font-weight: bold; ">C</i>
                    </span>
                </div>
                <p>以上的边界无法围成一个区域，在这种情况下，包含块的宽度是负的。</p>
                <p><strong>2). 如果 'direction' 是 'rtl'，包含块的顶、右边是祖先元素生成的第一个框的顶、右内边距边界 (padding edges) ，左、下边是祖先元素生成的最后一个框的左、下内边距边界 (padding edges)</strong>，还用上面的例子来分析，只是把direction设为rtl</p>
                <pre>
<div style="border: 1px solid #CCCCCC;padding: 40px;width:200px;direction:rtl;" >
    祖先元素
    <span style="border:1px solid #00BEEE;color: #ED2754;position:relative;padding: 20px;">
        相对定位的行内元素，其子元素ABC的包含块顶、右边应该是SPAN 形成的第一个框（即第一行）的顶、右内边距边，
                        ABC包含块的左、下边是 SPAN 生成的最后一个框（最后一行）的左、下内边距边界
        <i style="position: absolute;top:0;left:0;color: deeppink;font-weight: bold; ">A</i>
        <i style="position: absolute;top: 20px; left:0;color: #009ec3;font-weight: bold; ">B</i>
        <i style="position: absolute;bottom:0; right:0;color: #B266B2;font-weight: bold; ">C</i>
    </span>
</div>
                </pre>
                <div style="border: 1px solid #CCCCCC;padding: 40px;width:200px;direction:rtl;">
                    祖先元素
                    <span style="border:1px solid #00BEEE;color: #ED2754;position:relative;padding: 20px;">
                        相对定位的行内元素，其子元素ABC的包含块顶、右边应该是SPAN 形成的第一个框（即第一行）的顶、右内边距边，
                        ABC包含块的左、下边是 SPAN 生成的最后一个框（最后一行）的左、下内边距边界
                        <i style="position: absolute;top:0;right:0;color: deeppink;font-weight: bold; ">A</i>
                        <i style="position: absolute;top: 20px; right:0;color: #009ec3;font-weight: bold; ">B</i>
                        <i style="position: absolute;bottom:0; left:0;color: #B266B2;font-weight: bold; ">C</i>
                    </span>
                </div>
                <p>同样这种情况下，浏览器也是不兼容的，不兼容行类似于第一点中提到的。</p>
                <p>其他情况下，如果祖先元素不是行内元素，那么包含块的区域应该是祖先元素的内边距边界，看以下例子</p>
                <pre>
 <div name="container" style="border: 1px solid #CCCCCC;padding: 40px;width:200px;position:relative;">
    祖先元素
    <div name="father" style="width:100%; height:100%; border:2px solid #00BEEE;">
        父节点
        <div name="son" style="border:1px solid deeppink; position:absolute; left:0; top:0;">absolute element</div>
    </div>
</div>
                </pre>

                <div name="container" style="border: 1px solid #CCCCCC;padding: 40px;width:200px;position:relative;">
                    祖先元素
                    <div name="father" style="width:100%; height:100%; border:2px solid #00BEEE;">
                        父节点
                        <div name="son" style="border:1px solid deeppink; position:absolute; left:0; top:0;">absolute element</div>
                    </div>
                </div>
                <p>上面例子中，son 的父元素虽是 father，但是按照标准它的包含块应该是 container。</p>
                <p><a href="http://www.w3help.org/zh-cn/kb/008/">原文地址</a></p>
            </div>
            <h3 paragraph>控制框(Controlling box)</h3>
            <div>
                <p paragraph><a href="http://www.w3.org/TR/CSS2/visuren.html#box-gen" target="_blank">控制块（Controlling box）</a>，
                    涉及到的内容有块级元素（Block-level elements）、行内元素（Inline-level elements）、块框（block boxes）、行内框（inline boxes）、
                    匿名块框（ Anonymous block boxes）、匿名行内框（Anonymous inline boxes）、插入框以及
                    <a href="http://www.w3.org/html/ig/zh/wiki/CSS2#propdef-display" title="">'display'</a> 属性。</p>
                <h4>块级元素和块框</h4>
              <p>块级元素是指文档中被格式化为块的元素，如：p，div等。
                    元素display某些选项值会形成块级元素，主要有：'block'，'list-item'，'run-in'（某些时候是块级元素，需要根据上下文来判断），以及'table'。</p>
                <p><span class="h-web-font-red">块框</span>(block box)：是指每个块级元素会生成基于上下文格式化的主框，该框会为子孙元素建立包含块，生成内容。并且该主框也是涉及所有定位体系的框。
                    某些块级元素在主块框之外会生成额外的框，比如：'list-item'元素，这些额外的框是基于这些主框来定位的，比如li中前面的小点或是数字等。</p>
                <p><span class="h-web-font-red">块级框</span>(block-level box)：是指块级元素生成的框。                </p>
                <p><span class="h-web-font-red">块容器</span>（block container）：是指能容的下块级元素的容器被称为block container。和块级框(block-level box)的不同，block container是一个独立的概念，所以即使是行元素inline-block，由于其内部格式化为块因而能容纳块级元素，所以同样是block container。</p>
                <p>上面的说法也可以这样理解：除了table以及替换元素以外，每一个块级框都是一个block container。并且每一个是 block container 的 block-level box，被称为 block box（Block-level boxes that are also block containers are  called block boxes. ）。 </p>
                <p>所以，块级框(block-level box)、块容器(block container)、块框(block box)，是完全不同的三个概念。在无歧义的情况下，有时我们把这三个简称为&rdquo;块&ldquo;。</p>
                <h4>行内元素和行内框</h4>
                <p>行内元素是指文档中那些不形成新的内容块的元素，内容在行内分布（如：段落内着重文本，行内图片等等）。元素display某些选项值会形成行内元素，主要有：'inline'，'inline-table'，'run-in'（某些时候是行内元素，需要根据上下文来判断）。行内元素生成行内框。</p>
                <h4>匿名块框</h4>
                <p>匿名块框也称匿名行框，首先还是看以下例子：</p>
                <pre>
<div style="border: 1px solid #006699;padding: 10px;">
    Some text
    <div style="border: 1px solid #00b7ea;">More text</div>
</div>
                </pre>
                <div style="border: 1px solid #006699;padding: 10px;">
                    Some text
                    <div style="border: 1px solid #00b7ea;">More text</div>
                </div>
                <p>上面例子中div包含行内内容和块内容。为了使格式化简单一些，我们假定有一个匿名块框围绕在"Some text"周围，如图：</p>
                <div style="text-align: center;">
                    <img src="images/anon-block.png" />
                    <div style="text-align: center;">上面的图中有 3 个框，最外层div 的 box，内层div 的 box，以及包含 “Some text” 的匿名块框。</div>
                </div>
            </div>
            
        </div>
    </body>
</html>